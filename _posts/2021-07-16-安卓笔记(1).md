---
layout: post
title: 安卓笔记(一)
date: 2021-07-16
tags: 安卓
---

## 一、Java基础

### 1.Java的char是两个字节，如何存UTF-8的字符？
概念: UTF-8是编码格式，unicode是字符集 ， char两个字节，一个字节=8个bit=2个十六进制  
Java中char存的编码格式为UTF-16,最少占2个字节   
```Java
byte[] bytes = "中".getBytes("utf-16");
```   
输出后长度是4个字节 fe ff 4e 2d  前面两个是字节序   
emoji表情 字符串长度是2 不等于字符个数

### 2.Java中String可以有多长？
两种形式
* 字面量（栈）
编译后的字节码（U8的结构体），有个u2（两个字节） 格式的的 length， 说明最多是2个字节 16位 65535。假如字符都是拉丁字符的话，实际会报错，65534就正常运行， 因为java编译器代码的bug，小于和小于等于写错了。有汉字或者其他非拉丁字符，就没事，因为要多一次编码，逻辑处理的方法不是一个，这里的判断逻辑是正常的。
* 文件读取的字符串，new出来的
理论上Integer.MAX_VALUE，实际上受虚拟机实现限制可能会小于这个值。假如堆内存很小，也会收到堆内存的限制。

### 3.Java的匿名内部类有哪些限制？
`匿名内部类`，没有人类认知的名字，实际编译器会给一个名字,`包名.OuterClass$1` 以此类推第二个是 $2。   
`匿名内部类继承结构`， 不能同时继承一个父类又实现一个接口。   
`匿名内部类的构造方法`，编译器创建的，非静态的匿名内部类会引用外部类的实例。方法如果是非静态的，还会引用自己的实例。   
`Lambda`表达式，只能是接口，并且只有一个方法时，()->{ } 替换原来的new XXX { xxx() }   

### 4.怎么理解Java的方法分派
`方法分派`，翻译过来就是 确定调用`谁的`，调用`哪个`。方法重载，方法复写。    
重载—>看声明,声明是啥就调用啥。Groovy完全兼容java语法，但是运行机制不一样，重载的时候 也会判断实际类型，然后调用。
复写—>看实际实例是那个，就调用那个。（子类，还是父类）。

### 5.Java泛型的实现机制是怎样的
Java类型擦除机制，在内存中实际最后都是同一种类型。
C#真实泛型，内存中也是不同类型。
* Java这种方式，方法区的压力会小一点。
* Java 1.5 推出泛型，为了兼容老版本（向后兼容）。  
#### 类型擦除会有哪些问题？
* 基本类型无法作为泛型实参，所以基本数据类型装箱和开箱，会增加开销。`SparseArray`的键值是int类型，不用开箱装箱，内存占用也小。
* 泛型类型无法用做方法重载。
* 泛型类型不能当做真实类型使用，不能 new T()，T.class, instanceof List(String)  等;
知识迁移：Gson.fromJson为什么要传入Class
* 静态方法无法引用类泛型参数
* 类型强转带来运行时开销，代码里虽然不用写强转的代码，但是编译后，类型擦除掉了，字节码会加上强转。
迁移：Gson
      Type collectionType = new TypeToken<Collection<Integer>>(){}.getType();
      Collection<Integer> ints = gson.fromJson(json,collectionType);
    Retrofit
      interface GitHubServiceApi{
        @GET("XXX/XXX")
        Call<User> getUser(@Path("xxx")String login);
      }
迁移：Kotlin反射的实现原理，泛型类型签名信息特定场景下，反射可以获取到。
思考：混淆的原理。

### 6.Activity的onActivityResult使用起来非常麻烦，为什么不设计成回调？
麻烦在哪里：
* 代码处理逻辑分离，容易出现遗漏和不一致问题。
* 写法不直观，且结果数据没有类型安全保障。
* 结果种类较多时，onActivityResult就会逐渐臃肿难以维护。   

为什么不使用呢？   
* 虽然麻烦，虽然callback回调可以简化代码，但是当activity的销毁和恢复机制`不允许匿名内部类`出现。

## 二、多线程并发  

### 1.停止一个线程  
线程有个`stop()`方法，不过已经被**废弃**了。  
为什么不能简单停止一个线程？  
线程1假如正在读写数据，直接被停止掉，线程2立马对内存块进行加锁，导致内存数据来不及清理。  
线程是一个协作的**任务执行**的模式。  
* 通知目标线程自行介绍，而不是强制停止。
* 目标线程应该具有处理中断的能力。
* 中断方式：  
    * Interrupt
    * boolean 标志位     

`Interrupt`   
原生支持的，例如sleep(),需要try-catch Interrupt异常。如果是自己写的代码，可以调用`interrupted()`查看中断状态。  


### 2.如何写线程安全的程序
#### 什么是线程安全
每个线程都有一个自己的内存副本，同时对同一块内存进行操作，由于时间片等，导致最后结果出现误差。   
**本质** 是<font color=red>可变</font>资源，线程间<font color=red>共享</font>的问题。

#### 如何实现线程安全
* 不共享资源。
    纯函数（可重入函数），ThreadLocal
    `ThreadLocal`是一个绑定到线程上的map
    ![ThreadLocal](/images/threadlocal.png)   
    `ThreadLocal`使用建议
    * 声明为全局静态final成员
    * 避免存储大量对象
    * 用完后及时移除对象
* 共享不可变资源。
    `final`, 非final的成员变量可能重排序到构造方法之外。    
    `volatile`, 主要是可见性，也有禁止重排序的功能。
* 共享可变资源
  * 可见性
    * 使用**final**关键字
    * 使用**volatile**关键字
    * 加锁，锁释放时会强制将缓存刷新到主内存
  * 操作原子性
    * 加锁，保证操作的互斥性
    * 使用CAS指令(如Unsafe.compareAndSwapInt)
    * 使用原子数值类型(如AtomicInteger)
    * 使用原子属性更新器(AtomicReferenceFieldUpdater)
  * 禁止重排序

### 3.ConcurrentHashMap如何支持并发访问？
#### CHM并发优化历程
* JDK5:分段锁，必要时加锁
* JDK6:优化二次Hash算法
* JDK7:段懒加载，volatile & cas
* JDK8:摒弃段，基于HashMap原理的并发实现  

![CHM分段锁](/images/CHM分段锁Hash优化.png)  
重点问题是 高位和低位Hash后能够均匀分布到各个段和表中。   
出现的问题有， key是整数时，高位3万多之内的数都集中到一个段中，违背了设计初衷，在JDK6的时候 优化了hash算法，保证了均匀分。    

CHM如何计数？    
JDK5~7 基于段元素个数求和，二次不同就加锁。    
JDK8 引入CounterCell,本质上也是分段计数。    

CHM是弱一致性的
* 添加元素后，不一定马上能读到
* 清空之后可能仍然会有元素
* 遍历之前的段元素的变化会读到
* 遍历之后的段元素变化读不到
* 遍历时元素发生变化不抛异常

HashTable的问题    
* 大锁：对hashtable对象加锁
* 长锁：直接对方法加锁
* 读写锁共用：只有一把锁，从头锁到尾    

CHM的解决方法
* 小锁：分段锁（5~7），桶节点锁（8）
* 短缩：先尝试获取，失败再加锁
* 分离读写锁：读失败再加锁（5~7），volatile读 CAS写（7~8）    
![锁的优化](/images/锁的优化.png)  

### 4.AtomicReference和AtomicReferenceFieldUpdater有何异同？
`AtomicReference`使用
![AtomicReference使用](/images/AtomicReference使用.png)    
`AtomicReferenceFieldUpdater`使用
![AtomicReferenceFieldUpdater使用](/images/AtomicReferenceFieldUpdater使用.png)    
AR和ARFU的对比    
AR会占用更多内存...    
使用ARFU的例子 1，BuffereInputStream。 2，val value by lazy    
**结论**    
* AR和ARFU的功能一致，原理相同，都基于Unsafe的CAS操作
* AR通常作为对象的成员使用，占16B(指针压缩)、24B(指针不压缩)
* ARFU通常作为类的静态成员使用，对实例成员进行修改
* AR使用更友好，ARFU更适合类实例比较多的场景

### 5.如何在Android中写出优雅的异步代码？
#### 什么是异步？   
代码不是按照写的顺序执行，可能在不同线程，也可以在同一个线程(例如onClickListener都是在主线程)。    
#### 异步的目的是什么？
* 提高CPU利用率
* 提升GUI程序的响应速度
* 异步不一定快！    
**回调地狱**    
多层回调嵌套。    
**RxJava解决回调地狱。**    
#### RxJava基本用法
待补充    
#### RxJava异常处理
.subscribe()的时候只处理了正常情况的逻辑，onError没有处理就会抛出异常。   
可以在.subscribe()创建匿名内部类处理onError等回调。    
可以在.subscribe()之前加一个onErrorReturnItem()，收到异常后做一个影射，转换成某种response。    
可以在RxJavaPlugins里做一个全局的异常捕获，上报错误时，注意判断一下e的类型，假如是OnErrorNotImplementedException，就上报e.getCause(),否则就上报e。
#### RxJava取消处理
**为什么要取消？**    
匿名内部类持有外部activity的引用，容易造成内存泄露。    
外部UI可能发生改变，易发生空指针。    
**如何取消处理？**    
第一种方法，逻辑没有问题，但是使用体验不好。   
* 1.声明Disposable列表
* 2.存储Disposable对象
* 3.清理Disposable对象    
第二种方法，采用AutoDispose框架，监听view的状态，自动取消。    
在创建过程中.as(AutoDispose.autoAutoDisposable(ViewScopeProvider.from(button)))     

#### Kotlin协程  
待补充    
#### Kotlin协程异常处理
待补充    
#### Kotlin协程取消处理

##  三、JNI编程

### 1.CPU架构适配需要注意哪些问题？
