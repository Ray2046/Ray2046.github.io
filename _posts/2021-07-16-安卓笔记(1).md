---
layout: post
title: 安卓笔记(一)
date: 2021-07-16
tags: 安卓
---

## 一、Java基础

### 1.Java的char是两个字节，如何存UTF-8的字符？
概念: UTF-8是编码格式，unicode是字符集 ， char两个字节，一个字节=8个bit=2个十六进制  
Java中char存的编码格式为UTF-16,最少占2个字节   
```Java
byte[] bytes = "中".getBytes("utf-16");
```   
输出后长度是4个字节 fe ff 4e 2d  前面两个是字节序   
emoji表情 字符串长度是2 不等于字符个数

### 2.Java中String可以有多长？
两种形式
* 字面量（栈）
编译后的字节码（U8的结构体），有个u2（两个字节） 格式的的 length， 说明最多是2个字节 16位 65535。假如字符都是拉丁字符的话，实际会报错，65534就正常运行， 因为java编译器代码的bug，小于和小于等于写错了。有汉字或者其他非拉丁字符，就没事，因为要多一次编码，逻辑处理的方法不是一个，这里的判断逻辑是正常的。
* 文件读取的字符串，new出来的
理论上Integer.MAX_VALUE，实际上受虚拟机实现限制可能会小于这个值。假如堆内存很小，也会收到堆内存的限制。

### 3.Java的匿名内部类有哪些限制？
`匿名内部类`，没有人类认知的名字，实际编译器会给一个名字,`包名.OuterClass$1` 以此类推第二个是 $2。   
`匿名内部类继承结构`， 不能同时继承一个父类又实现一个接口。   
`匿名内部类的构造方法`，编译器创建的，非静态的匿名内部类会引用外部类的实例。方法如果是非静态的，还会引用自己的实例。   
`Lambda`表达式，只能是接口，并且只有一个方法时，()->{ } 替换原来的new XXX { xxx() }   

### 4.怎么理解Java的方法分派
`方法分派`，翻译过来就是 确定调用`谁的`，调用`哪个`。方法重载，方法复写。
重载—>看声明,声明是啥就调用啥。Groovy完全兼容java语法，但是运行机制不一样，重载的时候 也会判断实际类型，然后调用。
复写—>看实际实例是那个，就调用那个。（子类，还是父类）。

### 5.Java泛型的实现机制是怎样的
Java类型擦除机制，在内存中实际最后都是同一种类型。
C#真实泛型，内存中也是不同类型。
* Java这种方式，方法区的压力会小一点。
* Java 1.5 推出泛型，为了兼容老版本（向后兼容）。  
类型擦除会有哪些问题？
* 基本类型无法作为泛型实参，所以基本数据类型装箱和开箱，会增加开销。`SparseArray`的键值是int类型，不用开箱装箱，内存占用也小。
* 泛型类型无法用做方法重载。
* 泛型类型不能当做真实类型使用，不能 new T()，T.class, instanceof List(String)  等;
知识迁移：Gson.fromJson为什么要传入Class
* 静态方法无法引用类泛型参数
* 类型强转带来运行时开销，代码里虽然不用写强转的代码，但是编译后，类型擦除掉了，字节码会加上强转。
迁移：Gson
      Type collectionType = new TypeToken<Collection<Integer>>(){}.getType();
      Collection<Integer> ints = gson.fromJson(json,collectionType);
    Retrofit
      interface GitHubServiceApi{
        @GET("XXX/XXX")
        Call<User> getUser(@Path("xxx")String login);
      }
迁移：Kotlin反射的实现原理，泛型类型签名信息特定场景下，反射可以获取到。
思考：混淆的原理。

### 6.Activity的onActivityResult使用起来非常麻烦，为什么不设计成回调？
麻烦在哪里：
* 代码处理逻辑分离，容易出现遗漏和不一致问题。
* 写法不直观，且结果数据没有类型安全保障。
* 结果种类较多时，onActivityResult就会逐渐臃肿难以维护。   

为什么不使用呢？   
* 虽然麻烦，虽然callback回调可以简化代码，但是当activity的销毁和恢复机制`不允许匿名内部类`出现。

## 二、线程  

### 1.停止一个线程  
线程有个`stop()`方法，不过已经被**废弃**了。  
为什么不能简单停止一个线程？  
线程1假如正在读写数据，直接被停止掉，线程2立马对内存块进行加锁，导致内存数据来不及清理。  
线程是一个协作的**任务执行**的模式。  
* 通知目标线程自行介绍，而不是强制停止。
* 目标线程应该具有处理中断的能力。
* 中断方式：  
    * Interrupt
    * boolean 标志位  
`Interrupt`   
原生支持的，例如sleep(),需要try-catch Interrupt异常。如果是自己写的代码，可以调用`interrupted()`查看中断状态。  


### 2.如何写线程安全的程序
**什么是线程安全**  
每个线程都有一个自己的内存副本，同时对同一块内存进行操作，由于时间片等，导致最后结果出现误差。

**如何实现线程安全**  
* 不共享资源。
    纯函数（可重入函数），ThreadLocal
* 共享不可变资源。
    final, 非final的成员变量可能重排序到构造方法之外。
* 共享可变资源
  * 可见性
  * 操作原子性
  * 禁止重排序

### 3.ConcurrentHashMap
