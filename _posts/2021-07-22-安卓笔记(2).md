---
layout: post
title: 安卓笔记(二)：Activity、Handler
date: 2021-07-22
tags: 安卓
---

## 四、Activity相关

### 1.Activity的启动流程是怎样的？
**题目剖析**    
* 与AMS如何交互
* Activity的参数和结果如何传递
* Activity如何实例化
* Activity生命周期如何流转
* Activity的窗口如何展示
* Activity转场动画的实现机制    

#### Activity跨进程启动
可以参考这位大佬的[系列文章](http://liuwangshu.cn/framework/applicationprocess/1.html)

**跨进程**    
请求进程A（例如launcher进程，启动某一个APP）  --->>   通过AMP(AMS的代理)与AMS进行Binder通信  --->>  AMS解析Activity信息（主要就是Manifest文件里配置的信息）、处理启动参数、启动目标进程（通过Zygote）、绑定新进程  --->>   system_server通过调用ATP(目标进程B的ApplicationThread的代理)的scheduleLaunchActivity启动Activity在目标进程中（Binder通信）  --->>  ApplicationThread、ActivityThread、Activity生命周期     

Activity跨进程启动流程图        
![Activity跨进程启动流程图](/images/Activity跨进程启动流程图.png)

#### Activity进程内启动
**进程内**   
进程A  --->>  AMP  --->>  system_server进程  --->>  AMS解析信息，处理启动参数  --->>  ATP scheduleLaunchActivity --->>   进程A ApplicationThread、ActivityThread、Activity生命周期    

Activity进程内启动流程图    
![Activity进程内启动流程图](/images/Activity进程内启动.png)
两个小红圈的地方，就是可以进行插件化hook的地方

#### Activity的参数传递
跨进程通过Binder传递， Binder缓冲区 ①大小受<font color=red>缓冲区大小</font>限制 ②数据必须可以<font color=red>序列化</font>。    
两个Activity在同一进程的话，传递Key，通过贡献model，来存取数据。    
* Model可存内存或持久化
* 跨进程需实现进程通信机制

#### Activity实例化

```Java
Instrumentation
public Activity newActivity(ClassLoader cl, String className,
            Intent intent)
            throws InstantiationException, IllegalAccessException,
            ClassNotFoundException {
        String pkg = intent != null && intent.getComponent() != null
                ? intent.getComponent().getPackageName() : null;
        return getFactory(pkg).instantiateActivity(cl, className, intent);
    }
AppComponentFactory
public @NonNull Activity instantiateActivity(@NonNull ClassLoader cl, @NonNull String className,
            @Nullable Intent intent)
            throws InstantiationException, IllegalAccessException, ClassNotFoundException {
        return (Activity) cl.loadClass(className).newInstance();
    }
```

Activity不能添加构造方法，Fragment不能添加有参数的构造方法，因为在activity状态保存和恢复的时候，重新创建。    

#### Activity的窗口如何展示
![Activity的窗口如何展示](/images/Activity的窗口如何展示.png)

#### Activity转场动画的实现机制
安卓5.0之后加入的 类似keynote里神奇动画的效果。
**调用过程**    
![1](/images/Activity转场动画的实现机制1.png)
![2](/images/Activity转场动画的实现机制2.png)

### 2.如何跨App启动Activity？有哪些注意事项？
**题目剖析**    
--跨App    
--注意事项   

#### 跨App启动Activity有哪些方式？
* 共享uid的APP，manifest根节点android:sharedUserId="com.XXXX"，流量计算也是共享的（linux流量计算），方式：        intent.setComponent(new ComponentName("pkgname_b", "activity_b"));
* 使用exported， 在manifest activity节点，例如微信登陆。启动方式与上一个类似。
* 使用intentFilter action节点

#### 为允许外部启动的Activity加权限
![为允许外部启动的Activity加权限](/images/为允许外部启动的Activity加权限.png)
**注意：这种情况APP_B 一定要在APP_A之前安装。**

#### 拒绝服务漏洞
**原因是 Activity 从bundle中getExtra拿数据时，一定会将数据反序列化，这个过程中如果有未知的类，就会报异常。**     
**解决办法很简单，读传递的数据时，加一下try-catch**    

### 3.如何解决Activity参数的类型安全及接口繁琐的问题？
**题目剖析**    
* 类型安全：Bundle的K-V不能在编译期保证类型
* 接口繁琐：启动Activity时参数和结果传递都依赖Intent     
* 等价的问法：设计一个框架，解决上述问题    

**注解处理器+链式调用**    
![注解处理器_链式调用](/images/注解处理器_链式调用.png)    
参考库：[https://github.com/MarcinMoskala/ActivityStarter](https://github.com/MarcinMoskala/ActivityStarter)    

**注解处理器程序的基本思路**
![注解处理器程序的基本思路](/images/注解处理器程序的基本思路.png)    

#### 注解处理器程序的开发注意事项
* 注意注解标注的类的继承关系
* 注意注解标注的类为内部类的情况
* 注意Kotlin与Java的类型映射的问题
* 把握好代码生成和直接依赖的边界

#### 元编程
![元编程](/images/元编程.png)

### 4.如何在代码的任意位置为当前Activity添加View？
**题目剖析**    
任意位置，添加View    
* 如何获取当前Activity？
* 如何不影响正常View展示的情况下添加View？
* 既然能添加，就应当能移除，如何移除？
* 这样做的目的是什么？添加全局View是否更合适？

**获取当前Activity**    
ActivityLifecycleCallback， 在create或者resume中都可以获取，注意用WeakReference。

#### 内存回收机制
`GC Roots`没有引用到的内存，将在某一时刻被回收。    
`GC Roots`包括
* 虚拟机栈帧
* 类静态属性引用的对象
* 常量引用的对象
* Native方法引用的对象

`WeakRef` 弱引用    
`SoftRef` 软引用    
当可使用内存还有比较多的时候，GC的时候 只会回收`WeakRef` 弱引用。    
当内存爆满的时候， GC的时候 会把两个都回收。    

**添加View**    
contentView的ID是统一的content，直接activity.findViewById(android.R.id.content);    
`addView()`, `removeView()`;

#### 添加全局View
[参考文章](https://www.jianshu.com/p/af32b571476d)    
在Application中创建一个view添加到WindowManage，这里将视图为view的window的type设置成系统级别的窗口，这样这个window可以在在全局呈现。

### 5.如何实现类似微信右滑返回的效果？
**题目剖析**    
* 没有明说UI的类型，Activity还是Fragment?
* Fragment实现简单，重点回答Activity的实现
* 考虑如何设计这样一个组件
* 考虑如何降低接入成本

**Fragment**的实现    
* 对于Fragment的控制相对简单
* 不涉及window的控制，只是View级别的操作
* 实现View跟随手势滑动移动的效果
* 实现手势结束后判断取消或返回执行归位动画

**Activity**的实现    
* 除实现手势和动画之外，要处理好window
样式文件里 android:windowBackground 设置为 transparent 。    
android:windowIsTranslucent 设置为 true 。     
否则下面的activity不会被绘制，滑动的时候后面一直是黑色的。
* 多Task
针对这种情况可以保存一张当前activity的照片，放在新打开的activity的下面，栈的获取可以通过生命周期回调。    

**Activity透明对生命周期的影响** 上面的是透明的，下面状态是started，直到一个不透明的，下面的才不会被绘制。    

**现有方案**    
SwipeBackLayout，1、让activity继承SwipeBackActivity。 2、windowIsTranslucent = true。    
优化， 用接口 代替 父类。 动态切换窗口透明状态。


## 五、Handler相关

### 1.Activity中为什么非UI线程不能更新UI？
**题目剖析**    
非UI线程， 更新UI
* UI线程的工作机制
* 为什么UI设计成线程不安全的
* 非UI线程一定不能更新UI吗

#### UI线程是什么？
zygote --(fork)--> App进程 ----> ActivityThread(里面有个main方法) ----> Looper (loop)    
main方法里 主要的代码就是启动Looper的loop方法，一直循环，如果跳出了，下面会抛出异常 `Main thread loop unexpectedly exited`。    
主线程（UI线程），其他线程（非UI线程）    

#### 主线程如何工作
Handler.post()等方法生产消息，生产的消息存放在MessageQueue，Handler.dispatchMessage()分发处理消息，Looper在Main Thread中循环，传递消息。

**如果把UI设计成线程安全的** 反复加锁,影响性能。    
**UI为什么不设计成线程安全的**    
* UI具有可变性，甚至是高频可变性
* UI对响应时间的敏感性要求UI操作必须高效
* UI组件必须批量绘制来保证效率

#### 非UI线程一定不能更新UI吗
正常情况是 通过handler，或者 postInvalidate 更新UI。    
SurfaceView 的draw方法 不需要在主线程，prepare content之后 给画布加锁，然后draw，然后解锁。再通知U线程显示。    
GLSurfaceView（地图用的，SurfaceView的子类，通过OpenGL渲染），GLThread

### 2.Handler的delay可靠吗？
当handler所属的线程消息过多时，调用的时间**并非delay**的值。    
![handler流程](/images/handler流程.png)

#### MessageQueue如何处理消息
**新增消息** enqueueMessage(),  post,postdelay,sendmessage,等方法会调用次方法。     
新消息如果符合执行条件，则开始执行，否则插入队列中。    
Message 就是一个单链表。    
needWake->nativeWake() 没有消息的话会一直处于阻塞状态，直到有消息进来。    

**处理消息** Message.next()    
```Java
for(;;){
...
nativePollOnce(ptr, nextPollTimeoutMillis);

synchronized(this){
  Message msg = mMessages;
  ...
  if (msg != null) {
    if (now < msg.when) {
      nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
    }else {
      ...
      return msg;
    }
  }
}
}
```
nextPollTimeoutMillis如果是负一 就会阻塞。
![MessageQueue处理消息流程](/images/MessageQueue处理消息流程.png)    

**队列优化**  重复消息过滤、互斥消息取消、复用消息Message.obtain()、消息空闲IdleHandler、使用独享的Looper。     

**结论**    
* 大于Handler Looper的周期时基本可靠(例如主线程 > 50ms)
* Looper负载越高，任务越容易积压，进而导致卡顿
* 不要用Handler的delay作为计时的依据    

### 3.主线程的Looper为什么不会导致应用ANR?
**题目剖析**     
* ANR是怎么产生的？
* Looper的工作机制是什么？
* Looper不会导致应用ANR的本质原因是什么？
* Looper为什么不会导致CPU占用率高？

#### ANR的类型
* Service Timeout：
    * 前台服务 20s
    * 后台服务 200s
* BroadcaseQueue Timeout:
    * 前台广播 10s
    * 后台广播 60s
* ContentProvider Timeout: 10s
* InputDispatching Timeout: 5s    

**Service Timeout 的产生**     
AMS startService  ---->  ActiveServices (startServiceLocked、startServiceInnerLocked、bringUpServiceLocked、realStartServiceLocked、bumpServiceExecutingLocked、scheduleServiceTimeoutLocked)     
scheduleServiceTimeoutLocked会启动一个延时消息，延时的时长由前台服务，还是后台服务来决定。假如在这个时间之内执行完了，会调用serviceDoneExecutingLocked，在这个方法里会移除SERVICE_TIMEOUT_MSG消息，取消对服务方法执行时间的监控。相当于拆除了`定时炸弹`。埋炸弹是在realStartServiceLocked方法中调用bumpServiceExecutingLocked。    
![流程图](/images/ServiceTimeout的产生.png)    

#### Looper和ANR的关系
`Looper`是线程中整体的概念，`ANR`是进行到具体某一个环节时的一个耗时监控。    

#### Looper为什么不会导致CPU占用率高？
Looper底层没消息时是阻塞的，会调用native的epoll_wait方法，阻塞时不会消耗CPU时间片，所以不会导致CPU占用率高。    
epoll_create, epoll_ctl, epoll_wait， 句柄监控rbtree ， 就绪列表rdlist    
![epoll详解](/images/epoll详解.png)    

### 4.如何自己实现一个简单的Handler-Looper框架？

**Handler的核心能力**    
* 线程间通信
* 延迟任务执行    
 Handler      
 ---------         
 -mQueue:MessageQueue
 ---------      
 +sendmessage<br>+sendmessageDelayed<br>+post<br>+postDelayed         












------------------------
