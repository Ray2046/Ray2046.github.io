---
layout: post
title: 安卓笔记(二)：Activity、Handler、内存优化
date: 2021-07-22
tags: 安卓
---

## 四、Activity相关

### 1.Activity的启动流程是怎样的？
**题目剖析**    
* 与AMS如何交互
* Activity的参数和结果如何传递
* Activity如何实例化
* Activity生命周期如何流转
* Activity的窗口如何展示
* Activity转场动画的实现机制    

#### Activity跨进程启动
可以参考这位大佬的[系列文章](http://liuwangshu.cn/framework/applicationprocess/1.html)

**跨进程**    
请求进程A（例如launcher进程，启动某一个APP）  --->>   通过AMP(AMS的代理)与AMS进行Binder通信  --->>  AMS解析Activity信息（主要就是Manifest文件里配置的信息）、处理启动参数、启动目标进程（通过Zygote）、绑定新进程  --->>   system_server通过调用ATP(目标进程B的ApplicationThread的代理)的scheduleLaunchActivity启动Activity在目标进程中（Binder通信）  --->>  ApplicationThread、ActivityThread、Activity生命周期     

Activity跨进程启动流程图        
![Activity跨进程启动流程图](/images/Activity跨进程启动流程图.png)

#### Activity进程内启动
**进程内**   
进程A  --->>  AMP  --->>  system_server进程  --->>  AMS解析信息，处理启动参数  --->>  ATP scheduleLaunchActivity --->>   进程A ApplicationThread、ActivityThread、Activity生命周期    

Activity进程内启动流程图    
![Activity进程内启动流程图](/images/Activity进程内启动.png)
两个小红圈的地方，就是可以进行插件化hook的地方

#### Activity的参数传递
跨进程通过Binder传递， Binder缓冲区 ①大小受<font color=red>缓冲区大小</font>限制 ②数据必须可以<font color=red>序列化</font>。    
两个Activity在同一进程的话，传递Key，通过贡献model，来存取数据。    
* Model可存内存或持久化
* 跨进程需实现进程通信机制

#### Activity实例化

```Java
Instrumentation
public Activity newActivity(ClassLoader cl, String className,
            Intent intent)
            throws InstantiationException, IllegalAccessException,
            ClassNotFoundException {
        String pkg = intent != null && intent.getComponent() != null
                ? intent.getComponent().getPackageName() : null;
        return getFactory(pkg).instantiateActivity(cl, className, intent);
    }
AppComponentFactory
public @NonNull Activity instantiateActivity(@NonNull ClassLoader cl, @NonNull String className,
            @Nullable Intent intent)
            throws InstantiationException, IllegalAccessException, ClassNotFoundException {
        return (Activity) cl.loadClass(className).newInstance();
    }
```

Activity不能添加构造方法，Fragment不能添加有参数的构造方法，因为在activity状态保存和恢复的时候，重新创建。    

#### Activity的窗口如何展示
![Activity的窗口如何展示](/images/Activity的窗口如何展示.png)

#### Activity转场动画的实现机制
安卓5.0之后加入的 类似keynote里神奇动画的效果。
**调用过程**    
![1](/images/Activity转场动画的实现机制1.png)
![2](/images/Activity转场动画的实现机制2.png)

### 2.如何跨App启动Activity？有哪些注意事项？
**题目剖析**    
--跨App    
--注意事项   

#### 跨App启动Activity有哪些方式？
* 共享uid的APP，manifest根节点android:sharedUserId="com.XXXX"，流量计算也是共享的（linux流量计算），方式：        intent.setComponent(new ComponentName("pkgname_b", "activity_b"));
* 使用exported， 在manifest activity节点，例如微信登陆。启动方式与上一个类似。
* 使用intentFilter action节点

#### 为允许外部启动的Activity加权限
![为允许外部启动的Activity加权限](/images/为允许外部启动的Activity加权限.png)
**注意：这种情况APP_B 一定要在APP_A之前安装。**

#### 拒绝服务漏洞
**原因是 Activity 从bundle中getExtra拿数据时，一定会将数据反序列化，这个过程中如果有未知的类，就会报异常。**     
**解决办法很简单，读传递的数据时，加一下try-catch**    

### 3.如何解决Activity参数的类型安全及接口繁琐的问题？
**题目剖析**    
* 类型安全：Bundle的K-V不能在编译期保证类型
* 接口繁琐：启动Activity时参数和结果传递都依赖Intent     
* 等价的问法：设计一个框架，解决上述问题    

**注解处理器+链式调用**    
![注解处理器_链式调用](/images/注解处理器_链式调用.png)    
参考库：[https://github.com/MarcinMoskala/ActivityStarter](https://github.com/MarcinMoskala/ActivityStarter)    

**注解处理器程序的基本思路**
![注解处理器程序的基本思路](/images/注解处理器程序的基本思路.png)    

#### 注解处理器程序的开发注意事项
* 注意注解标注的类的继承关系
* 注意注解标注的类为内部类的情况
* 注意Kotlin与Java的类型映射的问题
* 把握好代码生成和直接依赖的边界

#### 元编程
![元编程](/images/元编程.png)

### 4.如何在代码的任意位置为当前Activity添加View？
**题目剖析**    
任意位置，添加View    
* 如何获取当前Activity？
* 如何不影响正常View展示的情况下添加View？
* 既然能添加，就应当能移除，如何移除？
* 这样做的目的是什么？添加全局View是否更合适？

**获取当前Activity**    
ActivityLifecycleCallback， 在create或者resume中都可以获取，注意用WeakReference。

#### 内存回收机制
`GC Roots`没有引用到的内存，将在某一时刻被回收。    
`GC Roots`包括
* 虚拟机栈帧
* 类静态属性引用的对象
* 常量引用的对象
* Native方法引用的对象

`WeakRef` 弱引用    
`SoftRef` 软引用    
当可使用内存还有比较多的时候，GC的时候 只会回收`WeakRef` 弱引用。    
当内存爆满的时候， GC的时候 会把两个都回收。    

**添加View**    
contentView的ID是统一的content，直接activity.findViewById(android.R.id.content);    
`addView()`, `removeView()`;

#### 添加全局View
[参考文章](https://www.jianshu.com/p/af32b571476d)    
在Application中创建一个view添加到WindowManage，这里将视图为view的window的type设置成系统级别的窗口，这样这个window可以在在全局呈现。

### 5.如何实现类似微信右滑返回的效果？
**题目剖析**    
* 没有明说UI的类型，Activity还是Fragment?
* Fragment实现简单，重点回答Activity的实现
* 考虑如何设计这样一个组件
* 考虑如何降低接入成本

**Fragment**的实现    
* 对于Fragment的控制相对简单
* 不涉及window的控制，只是View级别的操作
* 实现View跟随手势滑动移动的效果
* 实现手势结束后判断取消或返回执行归位动画

**Activity**的实现    
* 除实现手势和动画之外，要处理好window
样式文件里 android:windowBackground 设置为 transparent 。    
android:windowIsTranslucent 设置为 true 。     
否则下面的activity不会被绘制，滑动的时候后面一直是黑色的。
* 多Task
针对这种情况可以保存一张当前activity的照片，放在新打开的activity的下面，栈的获取可以通过生命周期回调。    

**Activity透明对生命周期的影响** 上面的是透明的，下面状态是started，直到一个不透明的，下面的才不会被绘制。    

**现有方案**    
SwipeBackLayout，1、让activity继承SwipeBackActivity。 2、windowIsTranslucent = true。    
优化， 用接口 代替 父类。 动态切换窗口透明状态。


## 五、Handler相关

### 1.Activity中为什么非UI线程不能更新UI？
**题目剖析**    
非UI线程， 更新UI
* UI线程的工作机制
* 为什么UI设计成线程不安全的
* 非UI线程一定不能更新UI吗

#### UI线程是什么？
zygote --(fork)--> App进程 ----> ActivityThread(里面有个main方法) ----> Looper (loop)    
main方法里 主要的代码就是启动Looper的loop方法，一直循环，如果跳出了，下面会抛出异常 `Main thread loop unexpectedly exited`。    
主线程（UI线程），其他线程（非UI线程）    

#### 主线程如何工作
Handler.post()等方法生产消息，生产的消息存放在MessageQueue，Handler.dispatchMessage()分发处理消息，Looper在Main Thread中循环，传递消息。

**如果把UI设计成线程安全的** 反复加锁,影响性能。    
**UI为什么不设计成线程安全的**    
* UI具有可变性，甚至是高频可变性
* UI对响应时间的敏感性要求UI操作必须高效
* UI组件必须批量绘制来保证效率

#### 非UI线程一定不能更新UI吗
正常情况是 通过handler，或者 postInvalidate 更新UI。    
SurfaceView 的draw方法 不需要在主线程，prepare content之后 给画布加锁，然后draw，然后解锁。再通知U线程显示。    
GLSurfaceView（地图用的，SurfaceView的子类，通过OpenGL渲染），GLThread

### 2.Handler的delay可靠吗？
当handler所属的线程消息过多时，调用的时间**并非delay**的值。    
![handler流程](/images/handler流程.png)

#### MessageQueue如何处理消息
**新增消息** enqueueMessage(),  post,postdelay,sendmessage,等方法会调用次方法。     
新消息如果符合执行条件，则开始执行，否则插入队列中。    
Message 就是一个单链表。    
needWake->nativeWake() 没有消息的话会一直处于阻塞状态，直到有消息进来。    

**处理消息** Message.next()    
```Java
for(;;){
...
nativePollOnce(ptr, nextPollTimeoutMillis);

synchronized(this){
  Message msg = mMessages;
  ...
  if (msg != null) {
    if (now < msg.when) {
      nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
    }else {
      ...
      return msg;
    }
  }
}
}
```
nextPollTimeoutMillis如果是负一 就会阻塞。
![MessageQueue处理消息流程](/images/MessageQueue处理消息流程.png)    

**队列优化**  重复消息过滤、互斥消息取消、复用消息Message.obtain()、消息空闲IdleHandler、使用独享的Looper。     

**结论**    
* 大于Handler Looper的周期时基本可靠(例如主线程 > 50ms)
* Looper负载越高，任务越容易积压，进而导致卡顿
* 不要用Handler的delay作为计时的依据    

### 3.主线程的Looper为什么不会导致应用ANR?
**题目剖析**     
* ANR是怎么产生的？
* Looper的工作机制是什么？
* Looper不会导致应用ANR的本质原因是什么？
* Looper为什么不会导致CPU占用率高？

#### ANR的类型
* Service Timeout：
    * 前台服务 20s
    * 后台服务 200s
* BroadcaseQueue Timeout:
    * 前台广播 10s
    * 后台广播 60s
* ContentProvider Timeout: 10s
* InputDispatching Timeout: 5s    

**Service Timeout 的产生**     
AMS startService  ---->  ActiveServices (startServiceLocked、startServiceInnerLocked、bringUpServiceLocked、realStartServiceLocked、bumpServiceExecutingLocked、scheduleServiceTimeoutLocked)     
scheduleServiceTimeoutLocked会启动一个延时消息，延时的时长由前台服务，还是后台服务来决定。假如在这个时间之内执行完了，会调用serviceDoneExecutingLocked，在这个方法里会移除SERVICE_TIMEOUT_MSG消息，取消对服务方法执行时间的监控。相当于拆除了`定时炸弹`。埋炸弹是在realStartServiceLocked方法中调用bumpServiceExecutingLocked。    
![流程图](/images/ServiceTimeout的产生.png)    

#### Looper和ANR的关系
`Looper`是线程中整体的概念，`ANR`是进行到具体某一个环节时的一个耗时监控。    

#### Looper为什么不会导致CPU占用率高？
Looper底层没消息时是阻塞的，会调用native的epoll_wait方法，阻塞时不会消耗CPU时间片，所以不会导致CPU占用率高。    
epoll_create, epoll_ctl, epoll_wait， 句柄监控rbtree ， 就绪列表rdlist    
![epoll详解](/images/epoll详解.png)    


### 4.如何自己实现一个简单的Handler-Looper框架？

**Handler的核心能力**    
* 线程间通信
* 延迟任务执行    
 ------------------------------------------      
 | **Handler**                
 ------------------------------------------         
 | -mQueue:MessageQueue       
 ------------------------------------------      
 | +sendmessage<br>| +sendmessageDelayed<br>| +post<br>| +postDelayed                
 ------------------------------------------     
安卓中handler实现delay使用的是真实时间。    

**Looper的核心能力**    
循环取消息，如果消息为空就继续，不为空就分发。    

**MessageQueue的核心能力**    
* 持有消息
* 消息按时间排序（优先级）
* 队列为空时阻塞读取
* 头结点有延时可以定时阻塞     
现成的结构 `DelayQueue` 包装了一个优先级队列，这个队列是基于堆实现的优先级排序。    

**Message**
因为使用了`DelayQueue`所以`Message`要实现Delayed接口，实现getDelay()和compareTo()。     

**HandlerThread**     

![类结构](/images/类结构.png)

#### DelayQueue如何处理消息顺序

**DelayQueue的阻塞机制**    
```Java
public E take() throws InterruptedException {
  final ReentrantLock lock = this.lock;
  lock.lockInterruptibly();
  for(;;){
    E first = q.peek();
    if (first == null) {
      available.await();
    }else{
      long delay = first.getDelay(NANOSECONDS);
      available.awaitNanos(delay); //类似 nativePollOnce(ptr, nextPollTimeoutMillis);
    }
  }
}
```

**Android为什么不直接复用DelayQueue**     
* DelayQueue没有提供合适的remove机制  
* 更大的自由度，可以定制许多功能，特别是与Native层结合
* Android的MQ可以针对单线程读取的场景做优化


## 六、内存优化

### 1.如何避免OOM的产生？
**题目剖析**    
* OOM如何产生？
* 如何优化程序减少内存占用？

#### OOM的产生
* 已使用内存 + 新申请内存 > 可分配内存
* OOM几乎覆盖所有的内存区域，通常指堆内存
* Native Heap 在物理内存不够时也会抛OOM

#### 解决方法     

**使用合适的数据结构**
![选择数据结构](/images/选择数据结构.png)    
大数据量，频繁增删时，使用HashMap。    
数据少，不频繁增删，Key是整型时，用SparseArray。SparseArray 也是一个map，避免了拆箱和装箱。    
数据少，不频繁增删，Key不是整型时，用ArrayMap,与HashMap主要区别是有缩容机制，无额外的对象开销，HashMap有个Entry对象，小数组复用池。      

**内存复用（池化）**    
ArrayMap里的小数组复用，Message里面的sPool，等等。    

**避免使用枚举**     
枚举的好处是类型安全，可读性强。但是占用内存太大，24字节。一个枚举会增加大约 **1.0到1.4KB** 的classes.dex文件。    
代替的方法可使用 `@IntDef` 和 `@interface`  或者 `Kotlin内联类`       
```Java
@IntDef({Int常量A, Int常量B, Int常量C})
@interface 类型{}

public void set名称(@类型 int p){ }
```

**Bitmap的使用**     
* 尽量根据实际需求选择合适的分辨率
* 注意原始文件分辨率与内存缩放的结果
* 不用帧动画，使用代码实现动效
* 考虑对Bitmap的重采样和复用配置

**谨慎的使用多进程**    
一个进程被Fork出来之后，会自带一些预加载的公共资源，开辟一个进程，只运行一行代码，同样也会占好几M内存。    

**谨慎的使用Large Heap**      
Java虚拟机 `-Xmx4096m`    
Android虚拟机 `android:largeHeap="true"`    

**使用NDK**       
* Native Heap 没有专门的使用限制
* 内存大户的核心逻辑主要在Native层
    * 各类基于`Cocos2dx`、`Unity3D`等框架的游戏
    * 游戏以外的OpenGL重度用户，例如各大地图APP

####





------------------------
