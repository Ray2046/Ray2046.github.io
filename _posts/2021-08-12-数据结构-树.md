---
layout: post
title: 数据结构-树
date: 2021-08-12
tags: 算法与数据结构
---

## 树的基本概念

* 节点、根节点、父节点、子节点、兄弟节点
* 一棵树可以没有任何节点，称之为空树
* 一棵树可以只有1个节点，也就是只有根节点
* 子树、左子树、右子树
* 节点的`度`（degree）：子树的个数
* 树的`度`：所有节点度中的最大值
* `叶子`节点：度为0的节点
* 非叶子节点：度不为0的节点
* `层数`（level）：根节点在第1层，根节点的子节点在第2层，以此类推（有些教程也从第0层开始计算）
* 节点的`深度`（depth）：从根节点到当前节点的唯一路径上的节点总数
* 节点的`高度`（height）：从当前节点到最远叶子节点的路径上的节点总数
* 树的`深度`：所有节点深度中的最大值
* 树的`高度`：所有节点高度中的最大值
* 有序树：树中任意节点的子节点之间有顺序关系
* 无序树：树中任意节点的子节点之间没有顺序关系，也叫“自由树”
* 森林：由m（m >= 0）棵互不相交的树组成的集合

## 二叉树（Binary Tree）

### 二叉树的特点
* 每个节点的`度`最大为2（最多拥有2棵子树）
* 左子树和右子树是有顺序的
* 即使某节点只有一棵子树，也要区分左右子树

### 二叉树的性质
* 非空二叉树的第i层，最多有`2^(i-1)`个节点（i >= 1）
* 在高度为h的二叉树上最多有`2^h - 1` 个节点（h >= 1）
* 对于任何一棵非空二叉树，如果叶子节点个数为 `n0`, 度为2的节点个数为`n2`, 则有：`n0 = n2 + 1`
     公式导出过程：
     * 假设度为1的节点个数为`n1`，那么二叉树的节点总数 `n = n0 + n1 + n2`
     * 二叉树的边数 `T = n1 + 2 * n2 = n - 1 = n0 + n1 + n2 - 1`


### 真二叉树和满二叉树

* `真二叉树`：所有节点的`度`都要么为0， 要么为2
* `满二叉树`：所有节点的`度`都要么为0， 要么为2。且所有的`叶子`节点都在最后一层
* 假设`满二叉树`的高度为h（h >= 1）,那么
    - [ ] 第i层的节点数量：`2^(i-1)`
    - [ ] 叶子节点数量：`2^(h-1)`
    - [ ] 总节点数量n
        - [x] `n = 2^h - 1 = 2^0 + 2^1 + ··· + 2^(h-1)`  
        - [x] `h = log2 (n+1)`

### 完全二叉树

`完全二叉树`：叶子节点只会出现最后2层，且最后1层的`叶子`节点都**靠左**对齐。可以理解为，节点从上到下，从左到右，挨着排布。    
**性质**：    
- [x] 度为1的节点只有左子树
- [x] 度为1的节点要么是1个，要么是0个
- [x] 同样节点数量的二叉树，完全二叉树的高度最小
- [x] 假设完全二叉树的高度为h(h >= 1)，那么
    - [ ] 至少有`2^(h-1)`个节点（2^0 + 2^1 + 2^2 + ··· + 2^(h-2) + 1）
    - [ ] 至多有`2^h - 1`个节点 (满二叉树)
    - [ ] 总节点数量为n  ---  2^(h-1) <= n < 2^h  ---  h - 1 <= log2 n < h  所以h = log2n向下取整+1     
            `floor` 向下取整    
            `ceiling` 向上取整    
- [x] 一棵有n个节点的完全二叉树（n > 0）, 从上到下、从左到右对节点从<font color=red>1</font>开始进行编号，对任意第i个节点
    - [ ] 如果 i = 1，它是根节点
    - [ ] 如果 i > 1，它的父节点编号为 `floor(i/2)`
    - [ ] 如果 2i <= n，它的左子节点编号为 `2i`
    - [ ] 如果 2i > n， 它无左子节点
    - [ ] 如果 2i + 1 <= n，它的右子节点编号为 `2i + 1`
    - [ ] 如果 2i + 1 > n， 它无右子节点
- [x] 一棵有n个节点的完全二叉树（n > 0）, 从上到下、从左到右对节点从<font color=red>0</font>开始进行编号，对任意第i个节点
    - [ ] 如果 i = 0，它是根节点
    - [ ] 如果 i > 0，它的父节点编号为 `floor((i-1)/2)`
    - [ ] 如果 2i + 1 <= n - 1，它的左子节点编号为 `2i + 1`
    - [ ] 如果 2i + 1 > n - 1， 它无左子节点
    - [ ] 如果 2i + 2 <= n - 1，它的右子节点编号为 `2i + 2`

#### 面试题
如果一棵完全二叉树有768个节点，求叶子节点的个数
- [ ] 假设叶子节点个数为 n0, 度为1的节点个数为 n1, 度为2的节点个数为 n2
- [ ] 总节点个数 n = n0 + n1 + n2，而且 n0 = n2 + 1, `n = 2n0 + n1 - 1`
- [ ] 完全二叉树的n1 要么为 0， 要么为 1。
      n1 = 1时，n = 2n0, n必然是偶数。    
      叶子节点 n/2 , 非叶子节点也是 n1 + n2 = n/2
      n1 = 0时，n = 2n0 - 1, n必然是奇数。
      叶子节点个数n0 = (n + 1)/2, 非叶子节点个数 n1 + n2 = (n - 1)/2
      **结论** n0 = (n+1) >> 1 = ceiling(n/2) , 非叶子节点个数 floor(n/2) = ceiling((n-1)/2)


## 二叉搜索树
最坏情况下，查询，插入，删除，都可以O(logN)

`二叉搜索树`(Binary Search Tree)是二叉树的一种，是应用非常广泛的一种二叉树，英文简称BST。    
又被称为： `二叉查找树`、`二叉排序树`    
- [x] 任意一个节点的值都**大于**其**左**子树所有节点的值
- [x] 任意一个节点的值都**小于**其**右**子树所有节点的值
- [x] 它的左右子树也是一棵二叉搜索树
* 二叉搜索树可以大大提高搜索数据的效率
* 二叉搜索树存储的元素必须具备可比较性
    - [x] 比如`int`、`double`等
    - [x] 如果是自定义类型，需要指定比较方式
    - [x] 不允许为`null`

### 二叉搜索树的接口设计
* int size() // 元素的数量
* boolean isEmpty() // 是否为空
* void clear() // 清空所有元素
* void add(E element) // 添加元素
* void remove(E element) // 删除元素
* boolean contains(E element) // 是否包含某元素

### 二叉搜索树的具体实现
`add方法`
```Java
public void add(E element){
        elementNotNullCheck(element);
        //添加第一个节点
        if (root == null){
            root = new Node<>(element, null);
            size++;
            return;
        }
        //添加的不是第一个节点 步骤：1.找到父节点parent 2.创建新节点node 3.parent.left = node 或者 parent.right = node
        //遇到值相等的元素该如何处理？ 建议覆盖旧的值
        //找到父节点
        Node<E> parent = null;
        int cmp = 0;
        Node<E> node = root;
        while (node != null){
            cmp = compare(element, node.element);
            parent = node;
            if (cmp > 0){
                node = node.right;
            }else if (cmp < 0){
                node = node.left;
            }else { //相等
                return;
            }
        }
        // 看看插入到父节点的哪个位置
        Node<E> newNode = new Node<>(element, parent);
        if (cmp > 0){
            parent.right = newNode;
        }else {
            parent.left = newNode;
        }
        size++;
    }
```

### 二叉树的遍历
- [x] 遍历是数据结构中的常见操作，把所有元素都访问一遍
- [x] 线性数据结构的遍历比较简单：正序遍历，逆序遍历
- [x] 根据节点访问顺序的不同，二叉树的常见遍历方式有4种
    - [ ] 前序遍历（Preorder Traversal）
    - [ ] 中序遍历（Inorder Traversal）
    - [ ] 后序遍历（Postorder Traversal）
    - [ ] 层序遍历（Level Order Traversal）

#### 前序遍历（Preorder Traversal）
先访问`根节点`、前序遍历`左`子树、前序遍历`右`子树

#### 中序遍历（Inorder Traversal）
中序遍历`左`子树、`根节点`、中序遍历`右`子树     
二叉搜索树，中序遍历，结果是从小到大排列。

#### 后序遍历（Postorder Traversal）
后序遍历`左`子树、后序遍历`右`子树、`根节点`    

#### 层序遍历（Level Order Traversal）
* 访问顺序：从上到下、从左到右依次访问每一个节点。
* 实现思路：使用队列     
    - [x] 1.将根节点入队     
    - [x] 2.循环执行以下操作，直到队列为空
        - [ ] 将队头节点A出队，进行访问
        - [ ] 将A的左子节点入队
        - [ ] 将A的右子节点入队

#### 遍历接口
将遍历处理数据的逻辑用匿名接口的形式传进来，方法返回值可以用于停止遍历，对于递归的情况，可以将接口改为抽象类，然后在抽象类内部增加一个变量标志，用于存放停止信号。    

#### 遍历的应用
* 利用前序遍历树状打印二叉树
* 二叉搜索树的中序遍历按升序或者降序处理节点
* 后序遍历适用于一些先子后父的操作
* 层序遍历： 1.计算二叉树的高度 2.判断一棵树是否为完全二叉树







-------------
